Основные правила

• Любая функция, реализованная в заголовке (кроме шаблонов), и любой незащищенный заголовок означает 0 для упражнения.
• Введенные имена файлов должны следовать до буквы, так же как имена классов, имена функций и имена методов.
• Помните: вы сейчас кодите на C ++, а не на C. Следовательно:
◦ Следующие функции ЗАПРЕЩЕНЫ, и их использование будет наказано 0, без вопросов: * alloc, * printf и free.
◦ Вам разрешено использовать все, что есть в стандартной библиотеке. ОДНАКО, было бы разумно попробовать использовать C ++ - ишевые версии функций, к которым вы привыкли в C, вместо того, чтобы просто придерживаться того, что вы знаете, в конце концов, это новый язык.
◦ Поскольку ваша цель здесь - перекодировать библиотеку STL, вы, конечно, не можете использовать сами контейнеры.
• Фактически, использование любой явно запрещенной функции или механизма будет наказываться 0 без вопросов.
• Также обратите внимание, что если не указано иное, ключевые слова C ++ «using namespace» и «friend» запрещены. Их использование будет наказано -42, без вопросов.
• Файлы, связанные с классом, всегда будут ClassName.hpp и ClassName.cpp, если не указано иное.
• Вы должны внимательно прочитать примеры. Они могут содержать требования, которые не очевидны в описании упражнения. Если что-то кажется неоднозначным, вы недостаточно разбираетесь в C ++.
• Поскольку вам разрешено использовать инструменты C ++, о которых вы узнали с самого начала, вам не разрешается использовать какие-либо внешние библиотеки. И прежде чем вы спросите, это также означает отсутствие C ++ 11 и его производных, а также Boost.
• Прочтите каждый проект ПОЛНОСТЬЮ перед его запуском! Действительно, сделай это.

// OK
• Используемый компилятор - clang ++.
// OK
• Ваш код должен быть скомпилирован со следующими флагами: -Wall -Wextra -Werror -std = c ++ 98.


• Каждое из ваших включений должно иметь возможность включаться независимо от других. Включаемые элементы должны содержать все остальные включения, от которых они зависят, очевидно.
• Если вам интересно, в C ++ стиль кодирования не применяется. Вы можете использовать любой понравившийся стиль, без ограничений. Но помните, что код, который ваш коллега-оценщик не может прочитать, - это код, который он или она не может оценить.
• Важный момент: программа НЕ будет выставлять вам оценку. Однако НЕ ленитесь, вы пропустите МНОГО из того, что они могут предложить!
• Не проблема иметь какие-то посторонние файлы в том, что вы передаете, вы можете разделить свой код на большее количество файлов, чем то, что от вас требуется. Не стесняйтесь, если результат не оценивается программой.
• Даже если тема упражнения короткая, стоит потратить на нее некоторое время, чтобы быть абсолютно уверенным, что вы понимаете, чего от вас ждут, и что вы сделали это наилучшим образом.
• Один, Тор! Используй свой мозг!!!

Цели

В этом проекте вы реализуете различные типы контейнеров стандартной библиотеки шаблонов C ++. Для каждого контейнера включите файлы классов с соответствующими именами.
Пространством имен всегда будет ft, и ваши контейнеры будут проверяться с использованием ft :: <container>. Вы должны соблюдать структуру ссылочного контейнера. Если в нем отсутствует часть ортодоксальной канонической формы, не применяйте ее. Напоминаем, что мы кодируем C ++ 98, поэтому любая новая функция контейнеров НЕ ДОЛЖНА быть реализована, но ожидается каждая старая функция (даже устаревшая).

Обязательная часть

• Реализуйте следующие контейнеры и включите необходимые файлы <container> .hpp
• Вы также должны предоставить main.cpp, который проверяет все для ваших оценок. (нужно идти дальше примера!)
• Вы должны создать один двоичный файл только с вашими контейнерами и один с таким же тестированием с контейнерами STL.
• Сравните выходы и время (вы можете быть в 20 раз медленнее).
• Ожидаются функции-члены, не-члены и перегрузки.
• уважайте наименования, заботьтесь о деталях.
• Вы должны использовать std :: allocator.
• Вы должны обосновать свою внутреннюю структуру данных для каждого контейнера (использование простого массива для карты недопустимо).
• Если в контейнере есть итераторная система, вы должны ее реализовать.

// iterators_traits, reverse_iterator OK

• iterators_traits, reverse_iterator, enable_if, is_integral, равенства / лексикографического сравнения, std :: pair, std :: make_pair должны быть повторно реализованы.


• Вы можете использовать https://www.cplusplus.com/ и https://cppreference.com/ в качестве
использованная литература.
• Вы не можете реализовать больше общедоступных функций, чем те, которые предлагаются в стандартных контейнерах. Все остальное должно быть приватным или защищенным. Каждая публичная функция / -
переменная должна быть обоснована.
• Для перегрузок, не являющихся членами, разрешено ключевое слово friend. Каждое использование друга должно быть обосновано и проверяться во время оценки.

Вы должны включить следующие контейнеры и связанные с ними функции:
• Vector
• Map
• Stack

Для вашей векторной реализации не обязательно кодировать специализацию vector <bool>. Ваш стек будет использовать ваш векторный класс в качестве нижележащего контейнера по умолчанию, он по-прежнему должен быть совместим с другими контейнерами, такими как STL. Контейнеры STL запрещены. Вам разрешено использовать библиотеку STD.

Бонусная часть

Если вы выполнили обязательную часть, вы можете попробовать сдать бонусы.
В качестве бонуса последний контейнер:
•  Set - но на этот раз черно-красное дерево обязательно.


Docs
1. allocator_traits
Шаблон класса allocator_traits предоставляет стандартизированный способ доступа к различным свойствам распределителей. Стандартные контейнеры и другие компоненты стандартной библиотеки получают доступ к распределителям через этот шаблон, что позволяет использовать любой тип класса в качестве распределителя, если предоставленная пользователем специализация allocator_traits реализует все необходимые функции.

2. std::allocator
Шаблон класса std :: allocator является распределителем по умолчанию, используемым всеми стандартными библиотечными контейнерами, если не указан пользовательский распределитель. Распределитель по умолчанию не имеет состояния, то есть все экземпляры данного распределителя взаимозаменяемы, сравниваются одинаково и могут освобождать память, выделенную любым другим экземпляром того же типа распределителя.